####一、程序的基本概念；常量、变量和表达式；简单函数
* C规定变量必须以字母和下划线开头，但是尽量不要以下划线开头，因为其往往被编译器用作一些功能扩展.      
* 分配存储空间的函数声明可以叫函数定义，只有带函数体的声明才叫定义.      
* C语言的函数可以有`Side Effect`，这一点是它和数学函数在概念上的根本区别.     
* `#include <stdio.h>` ,这些通常都位于`/usr/include` 目录下面.
* `include <math.h>`时，`gcc test.c -lm` (`/lib/libm.so`,默认是`/lib/libc.so` `gcc test.c -lc`,与线程相关的 `/lib/libpthread.so`).        
* main函数的标准形式 `int main(int argc, char *argv[])` , `int main(void)` 也可以.     
* 定义变量时可以把相同类型的变量写到一起，但是定义参数时却不可以.    
``` c 
     void print_time(int hour, int minute)
     {
          printf("%d:%d\n",hour, minute);
     }
     
      void print_time(int hour, minute)  //这是错误的
```
* 形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化.           
* `Man Page Section` <pre><code>1 用户命令 如：ls(1)
2 系统调用 如：_exit(2)
3 库函数 如：printf(3)
4 特殊文件 如：null(4)描述了设备文件/dev/null、/dev/zero的作用
5 系统配置文件的格式 如：passwd(5)描述了系统配置文件/etc/passwd的格式
6 游戏
7 其他杂项 如：bash-builtins(7)描述了bash的各种内建命令
8 系统管理命令 如：ifconfig(8)
PS：man -k printf 可以查看哪些主题包含printf关键字
用户命令通常位于/bin 和 /usr/bin
系统命令通常位于/sbin 和 /usr/sbin</pre></code> 
* C语言不允许嵌套定义函数.     
* 局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式来初始化(constant expression).      
* 如果全局变量在定义时不初始化则初始值为0，如果局部变量在定义时不初始化则初始值是不确定的，所以局部变量在使用之前一定要先赋值，否则基于一个不确定的数值做后续运算肯定会引入bug.       
* 局部变量的存储空间在每次函数调用时分配，函数返回时释放；全局变量在程序运行时分配存储空间，结束时释放存储空间.      
* 全局变量慎用.       

####二、分支语句；深入理解函数；循环语句
* 相等性运算符(==、!=)的优先级低于关系运算符.         
* `%`取模运算符 (a/b)*b+a%b=a,取模运算符的结果总是以被除数同号.          
* else总是与它最近的一个if配对.          
* 浮点型的精度有限，不适合用 == 运算符做精确比较.           
* 使用switch语句要注意：case后面必须是常量表达式，这和全局变量的初始值一样必须在编译时计算出来；浮点型不适合做精确比较，所以case后  面的表达式必须是整型常量表达式；进入case后如果没有遇到break语句就会一直往下执行，遇到break就会跳出整个switch语句块.            
* 在没有返回值的函数中也可以使用return语句，例如当检查到一个错误时提前结束当前函数的执行并返回.         
* C语言的传参规则是Call By Value(按值传递)，返回值也是按值传递的，即便是写成return x; 也是返回变量x的值，而不是x本身.          
* for(控制表达式1；控制表达式2；控制表达式3)，C规定如果控制表达式2的值为空，默认为真.          
* `a+++++b`应该理解为`a++ ++ +b`,但是`a++`的结果不能作左值，所以最终编译器会报错.       
* break语句用来跳出switch语句块，也可以用来跳出循环体；continue语句终止当前循环又回到循环体的开头准备执行下一次循环.            
* goto只能跳转到同一个函数中的某个标号处，而不能跳转到别的函数；不要滥用goto.     
* C99规定了一种新的for循环语法，在控制表达式1的位置可以有变量定义，不过编译时要加上`gcc -std=c99` 或者`gcc -std=gnu99`.
```     
  #include <stdio.h>
    int main( void )
    {
         for( int i = 1; i< 10 ; i++ )
                {
                    printf( "%d\n", i );
                 }
         return 0;
    }
```

####三、结构体; 数组
* 结构体定义
``` c
	 struct complex_struct {
           double x, y;
      }; <===========分号不能少
     struct z1, z2;

     struct complex_struct {
           double x, y;
      } z3, z4;       <=======这样定义就没办法再次引用这个结构体类型了
```
``` c
#include <stdio.h>
int main(void)
{    
     struct complex_struct {double x, y;};
     struct complex_struct z1,z2;
     z1.x = 1.0, z2.x = 3;
     z1.y = 2.0, z2.y = 4;
     printf("%f+%fi\n",z1.x+z2.x,z1.y+z2.y);
     return 0;
}
``` 
`struct complex_struct z = {3.0, 4.0};  <===结构体变量也可以在定义时初始化；如果初始化的数据比结构体成员多是错误的，如果只是末尾多个逗号不算错，如果比结构体成员少，未指定的成员将用0来初始化.`
<pre><code>struct complex_struct z5 ;
z5 = { 3.0, 4.0 }            <===========这是错误的
</pre></code>    
`struct complex_struct z6 ={ .y = 2.0};   /* z6.x=0, z6.y=2.0 */` 
结构体变量之间可以相互赋值和初始化，也可以当做函数的参数和返回值来传递.  

* 数据类型标志
```  c
enum coordinate_type ( RECTANGULAR, POLAR);
/*RECTANGULAR是常量0,POLAR是常量1；也可以指定enum coordinate_type ( RECTANGULAR=1, POLAR); */
struct complex_struct {                                                          
     enum coordinate_type t;
     double a, b;
};
```
结构体的成员和变量名不在同一命名空间中，但枚举的成员名却和变量名在同一命名空间中，所以会出现命名冲突.
``` c
int main(void)
{
     enum coordinate_type {RECTANGULAR = 1, POLAR};
     int RECTANGULAR;                                                <=================这是错误的；
     printf("%d %d\n", RECTANGULAR, POLAR);
     return 0;
}
``` 

* 访问嵌套结构体的成员要用多个运算符 s.start.b = 2.0     
* 数组由一系列相同类型的元素组成
``` c         
     定义一个由4个结构体元素组成的数组：
     struct complex_struct {
          double x, y;
     } a[4];
     也可以定义一个包含数组元素的结构体
     struct {
          double x, y;
          int count[4];
     } s;
```
  数组下标不能超出数组的长度范围，在使用变量作数组下标的时候要特别注意；           
  数组不能相互赋值或初始化，也不能用数组类型作为函数的参数或返回值；数组类型作右值使用时，自动转换成指向数组首元素的指针.      

* rand() 函数会产生一个0到RAND_MAX之间的数，使用时要`#include<stdlib.h>`  
  rand() % 10 可以得到 0~9之间的数 

* `#define N 20` 定义一个常量     
  编译器的工作分为2个阶段，先是预处理阶段，才是编译阶段；define是在预处理阶段进行的，而枚举是在编译阶段处理的.

* 数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符.          
   `char c = "Hello, world!\n"[0];            <========= H`    
   但是通过下标修改其中的字符却是不允许的.        
   ` "Hello, world!\n"[0] = 'A';`     
   用于初始化的字符串字面值比数组长时，只包含字符串的前10个字符，不包含Null字符，这种情况编译器会给警告.     
   `char  str[10] = "Hello, world!\n";`       
   有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个Null字符的长度。      
   `char str[14] = "Hello, world!\n";  <======== 数组str不包含NULL字符，并且编译器不会给出警告，所以应该特别注意。`     
   printf会从数组str的开头一直打印到Null字符为止。如果数组中没有Null字符，那么printf函数就会访问数组越界，后果很诡异：有时打出乱码，有事看起来没错误，有时候引起程序崩溃. 

* 多维数组：除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度.

####四、编码风格
* 内核代码风格：     
  * 用缩进体现出语句块的层次关系，使用TAB字符缩进，不能用空格代替TAB；       
  * if/else、while、do/while、for、switch这些可以带语句块的语句,语句块的{或}应该和关键字写在同一行，用空格隔开，而不是单独占一行；       
  3. 函数定义的{和}单独占一行，这一点和语句块的规定不同；      
  4. switch和语句块里的case、default对齐写，但标号下的语句要往里缩进；       
  5. 用于goto语句的自定义标号应该顶头写不缩进，而不管标号下的语句缩进到第几层；         
  6. 代码中每个逻辑段落之间应该用一个空行隔开，例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行；      
  7. 一个函数的语句列表如果很长，也可以根据相关性分成若干组，用空行分隔，通常把变量定义分成一组，后面加空行，return语句之前加空行.             
* 注释：        
  * 整个源文件的顶部注释，顶头写不缩进；    
  * 函数注释，写在函数定义上侧，和此语句组之间不留空行，顶头写不缩进；     
  3. 相对独立的语句组注释，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致；      
  4. 代码行右侧的简短注释，一般为单行注释，和代码之间至少用一个空格隔开，一个源文件中的右侧注释最好能上下对齐；     
  5. 复杂的结构体定义比函数更需要注释；     
  6. 复杂的宏定义和变量声明也需要注释.     
* 标识符命名：     
  * 标识符命名要清晰明了，可以使用完整的单词和易于理解的缩写 count写成cnt，block写成blk， length写成len， window写成win， message写成msg，number写成nr，temporary写成temp或者tmp，internationalization写成i18n，词根trans经常写成x，如transmit写成xmit；      
  * 变量、函数和类型采用全小写加下划线的方式命名，常量(比如宏定义和枚举常量)采用全大写加下划线的方式命名（不用大小写混合命名和匈牙利命名法）；      
  3. 全局变量和全局函数的命名一定要详细，不惜多用几个单词多写几个下划线，局部变量和只在一个源文件中调用的内部函数的命名可以简略一些，但不能太短；     
  4. 禁止用汉语拼音做标识符，可读性差.    
* 每个函数都应该设计得尽可能简单，简单的函数才容易维护.     
* indent工具： `indent -kr -i8 test.c  <=======表示K&R风格，缩进8个空格的长度.`

这个笔记是之前记录的，前几天整理的时候就顺带把它同步到这了，发现`Markdown`这个东东还是蛮有意思的。另外喜欢简洁的朋友们可以关注一下简书，4月22日晚上10点半就已经上线公测版本了的。Good Luck!
