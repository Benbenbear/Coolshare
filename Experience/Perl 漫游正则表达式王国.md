正则表达式（regular expression），在Perl 里面通常也叫做模式（pattern），是用来表示匹配或不匹配某个字符串的特征模板。
* 使用简单模式  
若模式匹配的对象是$_的内容，只要把模式写在一对斜线"/"中就可以了。所有在双引号引起的字符串中能使用的技巧（尤其是反斜线转义）都可以在模式串里使用。如： `/cake\tsprite/`这个模式会匹配cake，一个制表符和sprite这11个字符。
* Unicode属性  
每个属性都有一个名字，完整的清单列在perluniprops文档中。若要匹配某项属性，只需要把属性名放入`\p{PROPERTY}`里面。如：  
`/\p{Space}/` 匹配空白符；  
`/\p{Digit}/` 匹配数字；  
`/\P{Space}/` 只要不是空白符都匹配（大写P）。
* 关于元字符  
点号（.）能匹配任意一个字符的通配符，换行符（“\n”）除外。要匹配点号本身，请在前面加上转义反斜线（“\”）。
* 简单的量词  
	星号（*）匹配前面的条目零次或者多次的。 注：点星（.*）匹配任意字符零次到无限次。  
	加号（+）匹配前一个条目一次以上。  
	问号（?）匹配前一个条目一次或者零次。  
这三个量词指定了前一个条目重复出现的次数，所以他们必须跟在某个东西之后。
* 模式分组
在正则表达式中，圆括号的作用是对字符串分组。如：
`/fred+/`会匹配像freddddddddd这样的字符串；
`/(fred)+/`会匹配fredfredfred这样的字符串。
我们还可以使用反向引用来引用圆括号中的模式所匹配的文字，这个行为我们称为捕获组。示例如下：

``` perl
#!/usr/bin/perl
use warnings;

$_ = "abba";
if (/(.)\1/) {  #匹配到'bb'
  print "Matched!\n";
}

$_ = "yabba dabba doo";
if (/y(....) d\1/) { #匹配y后面四个连续非换行符，d后面也是四个非连续换行符
  print "Matched!\n";
}

$_ = "yabba dabba doo";
if (/y(.)(.)\2\1/) { #匹配'abba'
  print "Matched!\n";
}

$_ = "yabba dabba doo";
if (/y((.)(.)\3\2) d\1/) { #匹配y后面'abba'，d后面也是'abba'
  print "Matched!\n";
}

use 5.010; 
$_ = "aa11bb";
if (/(.)\g{1}11/) {  #使用\g{1}可以消除干扰，也可以简写为\g1
  print "Matched!\n";
}

$_ = "xaa11bb";
if (/(.)(.)\g{-1}11/) {  #使用负数匹配相对位置，维护非常方便
  print "Matched!\n"
}
```
* 择一匹配  
竖线（|）可以用来要么匹配左边的内容，要么匹配右边的内容。
* 字符集  
它只匹配单个字符，但可以是字符集中列出的任何一个。如：[abcdef] 匹配这6个字符中的任意一个；也可以在字符集开头加上（^）来表示这些字符除外。如：[^abc]会匹配这三个字符以外的任意字符。
* 字符集的简写  
`\d` 表示任意一个数字的字符集的简写  
`\s` 能匹配空白符  
`\w` 匹配“单词”字符  
`\h` 水平空白符  
`\v` 垂直空白符  
`\R` 断行的字符，不管是什么操作系统  
其实很多情况下，应当尽量选用范围明确，可维护性好的模式来定义字符集，避免一位采用简写带来预期之外的效果。
* 反义简写  
`[^\d],[^\w],[^\s]`等价于`[\D],[\W],[\S]`,都表示一个非数字字符，非单词字符或者非空白字符。  
`[\d\D]`, 表示任何数字或非数字，也就是会匹配任意字符，包括换行符。  
`[^\d\D]`,匹配既不是数字也不是非数字的字符，其实也就是什么都不匹配。  

_ _ _
OK! Good Luck!

